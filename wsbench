#!/bin/env node

var OptionParser = require('./lib/optparse').OptionParser;
var sys = require('sys');
var url = require('url');
var WebSocket = require('./lib/websocket').WebSocket;

var OPTIONS = {
    connections : 10,
    rate : 0
};

var op = new OptionParser([
    ['-c', '--num-conns NUMBER',
        'number of connections to open (default: 10)'
    ],
    ['-h', '--help',
        'display this help'
    ],
    ['-p', '--protocol PROTO',
        'set the Web Socket protocol to use (default: empty)'
    ],
    ['-r', '--rate NUMBER',
        'number of connections per second (default: 0)'
    ]
]);

op.on('num-conns', function(o, v) {
    OPTIONS.connections = v;
});
op.on('help', function() {
    console.log(op.toString());
    process.exit(0);
});
op.on('protocol', function(o, v) {
    OPTIONS.protocol = v;
});
op.on('rate', function(o, v) {
    OPTIONS.rate = v;
});
op.on(2, function(v) {
    OPTIONS.url = v;
});

op.banner = 'usage: wsbench [options] <url>\n' +
'\n' +
'Kick off a benchmarking run against the given ws:// URL.\n' +
'\n' +
'We can execute our workload in one of two ways: serially, wherein each\n' +
'connection is closed before the next is initiated; or in parallel, wherein\n' +
'a desired rate is specified and connections initiated to meet this rate,\n' +
'independent of the state of other connections. Serial execution is the\n' +
'default, and parallel execution can be specified using the -r <rate>\n' +
'option. Parallel execution is bounded by the total number of connections\n' +
'to be made, specified by the -c option.'

op.parse(process.argv);

if (!OPTIONS.url) {
    console.error('wsbench: missing required <url> parameter');
    console.log('');
    console.log(op.toString());
    process.exit(1);
}

if (!OPTIONS.rate) {
    // We have no rate; synchronous
    var cnt = 0;
    var createWS = function(src) {
        var ws = new WebSocket(src, OPTIONS.protocol);

        ws.onopen = function() {
            ws.close();
        };

        ws.onclose = function() {
            if (++cnt < OPTIONS.connections) {
                createWS(src);
            }
        };
    }

    createWS(OPTIONS.url);
} else {
    // We have a rate; parallel
    var cnt = 0;
    for (i = 0; i < OPTIONS.rate; i++) {
        setTimeout(function() {
            var iid = setInterval(function() {
                if (OPTIONS.connections > 0 &&
                    ++cnt >= OPTIONS.connections) {
                    clearInterval(iid);
                    return;
                }

                var ws = new WebSocket(OPTIONS.url, OPTIONS.protocol);

                ws.onopen = function() {
                    ws.close();
                };
            }, 1000);
        }, i * (1000 / OPTIONS.rate));
    }
}

// vim: filetype=javascript
